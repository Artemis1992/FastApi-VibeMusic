# ADR-001: Выбор Микросервисной Архитектуры

**Статус:** ✅ Принято  
**Дата:** 2025-11-30  
**Автор:** Student + Cursor AI Mentor

---

## Контекст

Необходимо разработать новую версию музыкальной платформы VobeMusic взамен существующего Django-монолита. Старая система имеет следующие проблемы:

1. **Сложность масштабирования:** Невозможно масштабировать отдельные компоненты (например, только поиск или только аутентификацию).
2. **Тесная связность:** Изменение в одном модуле требует полного перетестирования и передеплоя всего приложения.
3. **Технологическая зависимость:** Все компоненты привязаны к Django и Python, что ограничивает выбор инструментов.
4. **Медленная разработка:** Большая кодовая база замедляет онбординг новых разработчиков.
5. **Единая точка отказа:** Падение одного компонента останавливает всю систему.

---

## Решение

**Мы выбираем микросервисную архитектуру (Microservices Architecture)** с использованием:

- **FastAPI** как основной фреймворк для бэкенда
- **Kubernetes** для оркестрации
- **Kafka** для асинхронного взаимодействия
- **Database per Service** pattern

### Декомпозиция на сервисы:

1. **Auth Service** — Аутентификация и авторизация
2. **Content Service** — Управление постами
3. **Artist Service** — Артисты, альбомы, треки
4. **Comment Service** — Комментарии
5. **Feedback Service** — Обратная связь
6. **LLM Chat Service** — AI-чат
7. **Search Service** — Полнотекстовый поиск
8. **Gateway Service** — API Gateway
9. **Frontend Service** — UI

---

## Обоснование

### ✅ Преимущества

#### 1. Независимое Масштабирование
- Можно масштабировать только Search Service при росте нагрузки на поиск
- Content Service может работать на мощных серверах, а Chat Service — на GPU-инстансах

#### 2. Изоляция Отказов
- Падение Chat Service не влияет на просмотр постов
- Каждый сервис имеет свои health checks и fallback стратегии

#### 3. Технологическая Свобода
- Search Service использует Elasticsearch
- Chat Service может использовать специализированные LLM библиотеки
- Возможность использовать разные версии Python для разных сервисов

#### 4. Независимое Развертывание
- Обновление Auth Service не требует перезапуска Content Service
- Можно делать rollback отдельных сервисов
- CI/CD pipeline для каждого сервиса

#### 5. Организационная Масштабируемость
- Разные команды могут работать над разными сервисами
- Четкие границы ответственности
- Упрощенный онбординг (фокус на одном сервисе)

#### 6. Data Isolation
- Каждый сервис владеет своей БД (Database per Service)
- Снижение риска data corruption
- Независимая оптимизация схем БД

---

### ⚠️ Недостатки и Митигация

#### 1. Сложность Инфраструктуры
**Проблема:** Больше движущих частей (Kafka, K8s, мониторинг)  
**Митигация:**
- Использование Docker Compose для локальной разработки
- Helm charts для K8s
- Автоматизация через скрипты

#### 2. Распределенные Транзакции
**Проблема:** ACID транзакции между сервисами невозможны  
**Митигация:**
- Saga Pattern через Temporal (планируется)
- Idempotency keys для безопасных retry
- Eventual Consistency вместо Strong Consistency

#### 3. Сетевая Latency
**Проблема:** HTTP вызовы между сервисами медленнее, чем вызовы функций  
**Митигация:**
- Redis кэширование часто запрашиваемых данных
- Backend for Frontend (BFF) pattern в Gateway
- HTTP/2 и gRPC для быстрых коммуникаций

#### 4. Тестирование
**Проблема:** Сложнее тестировать интеграции  
**Митигация:**
- Contract Testing (Pact)
- End-to-End тесты в отдельном окружении
- Mock сервисы для юнит-тестов

#### 5. Мониторинг и Отладка
**Проблема:** Распределенные логи, сложно отследить ошибку  
**Митигация:**
- Correlation ID для трейсинга запросов
- Централизованное логирование (ELK Stack)
- Distributed Tracing (OpenTelemetry)

---

## Альтернативы

### 1. Модульный Монолит
**Описание:** Один проект с четким разделением на модули.

**Плюсы:**
- Проще разрабатывать и деплоить
- Меньше сетевых вызовов
- ACID транзакции из коробки

**Минусы:**
- Нельзя масштабировать отдельные части
- Тесная связность со временем
- Единая точка отказа

**Почему отклонено:** Не решает проблемы старого Django-монолита.

---

### 2. Serverless (FaaS)
**Описание:** AWS Lambda, Azure Functions для каждой функции.

**Плюсы:**
- Автоскейлинг из коробки
- Оплата за использование
- Нет управления серверами

**Минусы:**
- Cold start latency
- Vendor lock-in
- Сложность отладки
- Ограничения на время выполнения

**Почему отклонено:** Требует слишком большой фрагментации, не подходит для AI-чата (long-running).

---

### 3. Service-Oriented Architecture (SOA)
**Описание:** Похоже на микросервисы, но с Enterprise Service Bus (ESB).

**Плюсы:**
- Централизованная оркестрация
- Стандартизированные протоколы

**Минусы:**
- ESB становится узким местом
- Более тяжеловесная архитектура
- Менее гибкая, чем микросервисы

**Почему отклонено:** Слишком сложно для нашего масштаба, ESB — анти-паттерн для современных систем.

---

## Последствия

### Что нужно реализовать:

#### 1. Инфраструктура
- [x] Docker окружение
- [ ] Kubernetes кластер (Minikube для dev)
- [ ] Kafka (Redpanda)
- [ ] API Gateway (Nginx + Custom Gateway)

#### 2. Коммуникация
- [ ] HTTP клиенты с Circuit Breaker
- [ ] Kafka Producer/Consumer
- [ ] Correlation ID middleware
- [ ] Service Discovery (K8s DNS)

#### 3. Data Management
- [ ] Миграции для каждой БД
- [ ] Shared Nothing архитектура
- [ ] Data Replication стратегия (для Search)

#### 4. Observability
- [ ] Централизованное логирование
- [ ] Distributed Tracing
- [ ] Metrics (Prometheus)
- [ ] Dashboards (Grafana)

#### 5. DevOps
- [ ] CI/CD pipeline для каждого сервиса
- [ ] Helm charts
- [ ] Automated testing
- [ ] Blue-Green deployment

---

## Критерии Успеха

Решение считается успешным, если:

1. ✅ **Масштабируемость:** Можно масштабировать Search Service независимо на 10x без изменения других сервисов.
2. ✅ **Отказоустойчивость:** Падение Chat Service не влияет на просмотр постов (graceful degradation).
3. ✅ **Время деплоя:** < 5 минут на деплой одного сервиса без даунтайма.
4. ✅ **Latency:** < 200ms на Gateway для 95% запросов.
5. ✅ **Uptime:** 99.9% SLA для критичных сервисов (Auth, Content).

---

## Связанные ADR

- ADR-002: Database per Service Pattern
- ADR-003: Kafka для Event-Driven Architecture
- ADR-004: FastAPI как основной фреймворк

---

## Ссылки

1. [Martin Fowler - Microservices](https://martinfowler.com/microservices/)
2. [Sam Newman - Building Microservices](https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/)
3. [Microservices.io - Patterns](https://microservices.io/patterns/microservices.html)

---

**Статус:** ✅ Принято и начата реализация  
**Следующий пересмотр:** После MVP (через 3 месяца)

